其实每个模式名称就表明了该模式的作用，代理模式就是多一个代理类出来，替原对象进行一些操作，比如我们在租房子的时候回去找中介，为什么呢？
因为你对该地区房屋的信息掌握的不够全面，希望找一个更熟悉的人去帮你做，此处的代理就是这个意思。再如我们有的时候打官司，我们需要请律师，因为律师在法律方面有专长，
可以替我们进行操作，表达我们的想法。

动态代理模式通过使用反射，可以在运行期决定加载哪个类，避免了一个类对应一个代理的问题；同时，通过统一的invoke方法，统一了代理类对原函数的处理过程，
使用动态代理很大程度上减少了重复的代码，降低了维护的复杂性和成本。

不需要实现接口类

一、动态代理概述

    程序在运行期而不是编译器，生成被代理对象的代理对象，并且被代理对象并不需要和代理对象实现共同的接口。基于此，我们可以利用代理对象，
    提供一种以控制对被代理对象的访问。

1.1 动态代理的原理

    基于CGLIB的动态代理，其实就是利用了CGLIB，在运行时期生成被代理对象的子类，来作为代理对象。同时重写了被代理对象的所有方法。当我们用代理对象调用方法的时候，
    其实是调用的重写后的方法。该方法实际调用的是callback中的用户自定义的代码逻辑，例如权限验证。当验证通过了，则通过反射，反射出父类（被代理对象）的方法并调用（invoke）。
    那么问题来了，如何生成被代理对象的子类呢？我们事先并不知道谁是代理对象啊？而且我们在重写调用自定义逻辑呢？

1.2 CGLIB动态代理的底层实现

    CGLIB是一个强大的高性能的代码生成包。
    1. 它广泛的被许多AOP的框架使用，例如：Spring AOP和dynaop，为他们提供方法的interception（拦截）；
    2. hibernate使用CGLIB来代理单端single-ended(多对一和一对一)关联（对集合的延迟抓取，是采用其他机制实现的）；
    3. EasyMock和jMock是通过使用模仿（moke）对象来测试Java代码的包。
    它们都通过使用CGLIB来为那些没有接口的类创建模仿（moke）对象。

    CGLIB包的底层是通过使用一个小而快的字节码处理框架ASM(Java字节码操控框架)，来转换字节码并生成新的类。他其实就像JVM一样，可以加载一个指定的类。
    这样我们就可以实现在运行时期生成我们自定义的class了。下图为cglib与一些框架和语言的关系（CGLIB Library and ASM Bytecode Framework）
    
    
 二、应用场景

        远程代理：也就是为一个对象在不同的地址空间提供局部代表。这样可以隐藏一个对象存在不同地址空间的事实。例如：WebService、RPC、RMI(Remote Method Invocation)等。
        虚拟代理：是根据需要创建开销很大的对象。通过它来存放实例化需要很长时间的真实对象。例如：利用虚拟代理来优化页面的打开速度。
        安全代理：用来控制真实对象访问时的权限。一般用户对象应该在不同访问权限的时候。
        智能指引：是指当调用真实的对象时，代理处理另外一些事情。例如：Spring AOP、Hibernate等。

 